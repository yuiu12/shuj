让我们考虑一个自组织系统，例如鸟群或鱼群。我们可以将这个系统定义为一个由粒子组成的系统（例如，粒子是一只鸟）。我们还可以很好地近似地假设这些粒子在空间中移动，根据两个因素调整它们的位置：

特定粒子知道的最佳位置：鸟的想法对自己最好。
所有粒子相互“通信”给出的全局最佳位置：“主鸟”指示鸟做什么
那么，自然界中的“最好”是什么？为这只鸟做的最好办法是什么？什么最适合“蜂群”？我绝对不是问这个问题的合适人选，因为我真的不知道。我所知道的是，通过在 Nature 中观察这种行为，我们能够正式形成一个非常迷人的优化算法。换句话说，如果我们确实定义了什么是最好的，那么我们可以使用这种进化方法来优化我们选择的功能。

这种算法称为粒子群优化 （PSO）。 我知道，这是一个相当大的飞跃。什么是“优化”？为什么我们突然之间谈论数学？我们正在优化什么？在本文中，我将尝试涵盖所有这些步骤，更重要的是，我们将在 Python 中使用基于对象的编程来创建自己的 ParticleSwarmOptimizer（） 类。换句话说，我们将涵盖从理论到实践的 PSO 世界。

https://towardsdatascience.com/from-theory-to-practice-with-particle-swarm-optimization-using-python-5414bbe8feb6

我认为，这是非常优雅的。让我们总结一下：

我们首先选择一定数量的随机粒子（即位于随机位置的粒子）
我们根据速度参数移动这些粒子
这些速度由三个因素给出：惯性，它保持对先前速度的记忆，认知速度，它使我们朝着最适合粒子的方向移动，以及一个社会速度，它使我们保持向整组粒子建议的方向移动。
我们在每次迭代中都会不断更改这些粒子的位置，直到我们到达num_iteration。然后我们选择我们最好的选项。

